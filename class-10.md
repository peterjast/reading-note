# **Error Handling & Debugging**

* Understanding execution contexts helps you find the errors in your code

* Debugging involves deduction to find errors in your code

* The console helps you find where an error is located

* JS has 7 different types of errors

* Errors create an error object which tells you which line the error occurs and a description

* You can use try, catch, finally statements to handle errors and give users feedback

## Execution Contexts

### Execution context

* **Global context** refers to code that exists outside of functions

* **Function context** refers to code within a function

* **Eval context** refers to text executed like code in an internal function eval()

### Variable Scope

* **Global scope** is when a variable is declared outside of a function and can be used anywhere

* **Function-level scope** is when a variable is declared inside of a function, so it can only be used within the function

## Execution Context & Hoisting

* Two phases each time a script enters a new execution context

    1. Prepare
        * new scope is created
        * variables, functions and arguments are created
    1. Execute
        * it can assign values to variables
        * reference functions and run them
        * Execute statements

Functions in JS have *lexical* scope which means they are linked to the object they are defined within

## Errors

When an error is generated by a JS statement, it throws an exception and the interpreter stops and looks for exception-handling

* If your code may cause an error, you can **handle** the error with a set of statements

### Error Objects

#### Error objects contain the following properties

1. **name** - type of error
1. **message** - description
1. **fileNumber** - javascript file name
1. **lineNumber** - line number of error

#### Seven types of built-in error objects

1. **Error** - Generic error
1. **SyntaxError** - syntax has not been followed
1. **ReferenceError** - variabled referenced has not been declared or is not within scope
1. **TypeError** - unexpected data type
1. **RangeError** - numbers outside of acceptable range
1. **URIError** - incorrectly used encodeURI() or similar methods
1. **EvalError** - incorrectly used eval() function

### Dealing with Errors

#### Two ways to deal with errors

1. Debug the script to fix errors
1. Handle errors gracefully with try, catch, throw and finally statements

#### Debugging

This is tracking down the error in the code to fix it.

* Use your console to find errors

* Use console methods like console.log(), console.info(), console.warn(), console.error(), console.table(), console.assert()

* Use a breakpoint to pause execution and then you can check what values are stored in variables

* The **debugger** keyword can be used to create a breakpoint in your code

* You can place the **debugger** keyword in a conditional so it only triggers a breakpoint if condition is met

### Handling Exceptions

If you anticipate your code failing, use try, catch and finally

> try{
> // Try to execute this code
> } catch (exception) {
> // If there is an exception, run this code
> } finally {
> //This always gets executed
> }

#### try

* Use a **try** block for code that might throw an exception
* If an exception occurs, control is passed to catch block
* If you use **continue**, **break**, or **return** inside a try block it will go to finally option

#### catch

* One parameter: error object
* It lets you inform users something has gone wrong instead of your site crashing

#### finally

* Content of the **finally* block will run no matter what
* Used to clean up after previous two clauses

#### Throwing Errors

Generate your own errors before the interpreter creates them if you know something might cause a problem for your script

> throw new Error('message');

[Back to Table of Contents](https://peterjast.github.io/reading-notes/)
